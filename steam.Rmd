---
title: "Exploración de datos Steam"
subtitle: "EAD Exploración y Análisis de Datos"
author: "Xabier Sáez de Cámara"
date: "`r format(Sys.time(), '%A, %d de %B %Y')`"
lang: es-ES
urlcolor: blue
abstract: |
  En este trabajo vamos a explorar una base de datos sobre unos usuarios de la plataforma de videojuegos Steam. La idea principal es hacer un análisis de componentes principales para poder visualizar todos los usuarios en un plano y después hacer clústering para clasificarlos en distintas categorias.
  
output:
  pdf_document:
    df_print: kable
    toc: true
    toc_depth: 2
    number_sections: true
---

# Objetivo

El objetivo de este trabajo es explorar y visualizar datos que he extraído de la popular plataforma de distribución digital de videojuegos *Steam*^[http://store.steampowered.com/] creado por la compañía de desarrollo de videojuegos *Valve Corporation*^[http://www.valvesoftware.com/index.html]. *Steam* se publicó en el año 2002 como una plataforma para distribuir actualizaciones de sus juegos Half-Life y Counter-Strike e implementar sistemas anti piratería y anti trampas. Hoy en día es la mayor plataforma de distribución de videojuegos en PC, en el año 2017 se estima que tiene más de 150 millones de cuentas registradas y ha alcanzado 17.5 millones de de usuarios conectados simultáneamente. Hasta la fecha de 23 de diciembre de 2017 hay 28877 productos disponibles en la tienda^[https://steamdb.info/genres/].

En concreto, el objetivo es extraer información de un número reducido de usuarios de *Steam*, como el número de juegos y el número de etiquetas que tiene cada jugador divido por géneros. Cada juego de *Steam* tiene asociadas unas etiquetas (tags) que definen el juego (ej: Acción, Estrategia, Aventuras...), las etiquetas son asignadas por los jugadores. La idea es conseguir una lista de todos los juegos que tiene un usuario y por cada juego extraer sus etiquetas. Después cada jugador se define con un vector en el espacio de las distintas etiquetas y el número representa la frecuencia de aparición de una etiqueta en particular en su biblioteca de juegos. Por ejemplo el siguiente jugador (ejemplo inventado):

|Jugador|Juegos|Acción|Estrategia|Aventuras|
|:-----:|:----:|:----:|:--------:|:-------:|
|  1º   |  4   |   2  |     2    |    3    |

Tiene en total 4 juegos en su biblioteca y de esos 4 juegos 2 tienen la etiqueta de Acción, otros 2 la etiqueta de Estrategia y 3 la de Aventuras. En el caso real se van a usar 31 etiquetas distintas.

Primero se hará una exploración para visualizar los datos, después un análisis de componentes principales para la reducción de variables y finalmente un clustering para distinguir los jugadores en grupos.

# Crear el dataset

Todos los datos necesarios los he extraído de tres fuentes distintas que menciono en la siguiente subsección. El código fuente que he creado en Python3 está disponible en <https://github.com/xsaga/steamCrawl> en el archivo `steamcrawltags.py` (incluye comentarios). Hay dos datasets disponibles en la misma pagina, el principal es `tagsData.csv`, el otro dataset `valveemployee.csv` incluye la información de si el usuario es empleado de *Valve* o no.

## Extracción de los datos

1. **Descargar la lista de juegos de cada usuario:** Cada usuario de *Steam* tiene un identificador único (SteamID). Usando este identificador y la página oficial de la comunidad de *Steam* de cada usuario <http://steamcommunity.com/> se puede acceder al perfil de cada jugador (a no ser que el perfil sea privado). La lista de todos los juegos que tiene el usuario SteamID se puede acceder en esta dirección <http://steamcommunity.com/profiles/SteamID/games/?tab=all> sustituyendo [SteamID] por el identificador válido. En el código HTML de la página hay una variable `var rgGames` que contiene la lista detallada de los juegos en formato JSON^[JavaScript Object Notation] que se puede descargar fácilmente.

2. **Extraer las etiquetas de cada juego:** Después de descargar la lista de juegos de cada usuario vamos a extraer las etiquetas de cada juego usando la API pública que ofrece la página <https://steamspy.com/>. Cada juego tiene un identificador único que se puede usar para pedir la información. Por ejemplo, el juego *Half-Life 2* tiene el identificador 220 y se puede acceder a sus metadatos usando la siguiente dirección <http://steamspy.com/api.php?request=appdetails&appid=220> otra vez en formato JSON.

3. **Información adicional de cada usuario:** Es interesante saber la información básica de cada usuario, por ejemplo si el usuario es un empleado de *Valve Corporation*. Para ello se ha usado la siguiente página <https://steamid.eu/>

Para el dataset se han usado 33 variables: 2 de información general y 31 etiquetas de juegos. En total, *Steam* tiene más de 300 etiquetas disponibles para clasificar los juegos, pero yo he seleccionado las más populares y otras que me interesaban.

se han analizado 1500 usuarios distintos pero de esos solo 293 son validos (perfiles públicos y con al menos un juego). En total se han analizado las etiquetas de 10420 juegos distintos. Los detalles se pueden ver en el código disponible en GitHub.

## Descripción de las variables

Una breve explicación del significado de cada variable es la siguiente:

* `steamid` : El SteamID es un identificador único para cada usuario de Steam.
* `nJuegos` : El número de juegos que tiene cada usuario.
* `Indie` : Videojuegos independientes sin apoyo financiero de distribuidores. Pueden ser de cualquier género, pero suelen ser de estrategia, plataformas y similares.
* `Action` : Acción.
* `Adventure` : Aventuras.
* `Strategy` : Estrategia en general.
* `Simulation` : Juegos de simulación (conducción, vuelo, construcción...).
* `RPG` : Role Playing Game.
* `Free.to.Play` : Modelo de negocio en el que los juegos son gratuitos pero hay que pagar por añadidos dentro del juego como nuevos personajes o equipamiento.
* `Early.Access` : Modelo de negocio en el que un juego que aun no está terminado se pone a la venta por un precio reducido. El dinero que se consigue con las ventas se usa para financiar el juego y terminarlo.
* `Massively.Multiplayer` : Juegos multijugador con un número masivo de usuarios jugando simultáneamente en el mismo servidor (puede ser mas de 100 personas).
* `Sports` : Juegos de deportes.
* `Violent` : Juegos violentos. Generalmente juegos de acción/disparos con un grado de violencia adicional.
* `Racing` : Juegos de carreras.
* `Multiplayer` : Juegos que tienen opción de multijugador online. Multiplayer y Singleplayer no son etiquetas exclusivas.
* `Singleplayer` : Juegos que tienen modo de un solo jugador (modo historia). Multiplayer y Singleplayer no son etiquetas exclusivas.
* `Gore` : Juegos con un grado de violencia más explícita.
* `Puzzle` : Juegos de ingenio en el que se van resolviendo distintos problemas.
* `Horror` : Juegos de terror.
* `Shooter` : Etiqueta genérica para juegos de disparos.
* `FPS` : First Person Shooter. Shooters en primera persona.
* `First.Person` : Juegos con la cámara en primera persona (a diferencia de la tercera persona).
* `Survival` : Juegos de supervivencia. Recolectar recursos para fabricar objetos/armas y sobrevivir en un entorno hostil.
* `Difficult` : Juegos difíciles en general.
* `Rogue.like` : Juegos inspirados en el clásico juego 'Rogue'^[https://es.wikipedia.org/wiki/Rogue] de 1980. El jugador tiene que atravesar un entorno generado aleatoriamente y se caracteriza por ser difícil, largo y tener la mecánica de muerte permanente (después de morir se empieza de cero).  
* `Platformer` : Juegos de habilidad y plataformas.
* `Turn.Based.Strategy` : Estrategia por turnos.
* `Psychological.Horror` : Juegos de terror sin violencia explícita.
* `Action.RPG` : Action Role Playing Game.
* `RTS` : Real Time Strategy (a diferencia de la estrategia por turnos).
* `MMORPG` : Massive Multiplayer Online Role Playing Game.
* `JRPG` : Japanese Rol Playing Game. Estilo diferente a los RPG occidentales.
* `Zombies` : Juegos en el que intervienen de algún modo zombis.


# Exploración de los datos

Importar las librerías necesarias:
```{r import}
library(ggplot2)
library(gridExtra)  # grid.arrange
library(reshape2)   # melt
library(fmsb)       # radarchart
library(corrplot)
library(NbClust)
library(cluster)    # siluetas
```

Cargar los dos datasets. `steam` es el dataset principal, en `valve` se guarda la información para saber si un usuario es empleado de *Valve* o no.
```{r cargar-dataset}
steam <- read.csv("/home/xabier/Documentos/src/steamCrawl/tagsData.csv",
                  colClasses=c(steamid="character"))

valve <- read.csv("/home/xabier/Documentos/src/steamCrawl/valveemployee.csv",
                  colClasses=c(steamid="character", VALVE="factor"))
```

```{r head-dataset}
head(steam[,1:8])
head(valve)
```

De `r nrow(valve)` usuarios en total en el dataset, `r sum(valve$VALVE == 1)` perfiles corresponden a empleados de *Valve*.
```{r table-valve}
table(valve$VALVE)
```


Las variables en `steam` no están ordenadas de ningún modo en particular. Por eso, en la siguiente lista voy a reordenar las etiquetas de modo que las que sean similares estén agrupadas.
```{r orden-generos}
# orden de las variables(generos) agrupados por temas
orden.generos <- c(3,9,10,11,15,16,12,14,            # otros y deportes
                   6,27,7,18,26,24,25,30,8,29,31,32, # estrategia
                   23,28,19,33,17,                   # horror
                   13,20,21,22,4,5)                  # violento y accion
```

## Visualización inicial de los datos

Primero vamos a analizar la variable `nJuegos` que representa el número de juegos que tiene cada usuario para ver si hay diferencias en el número de juegos entre los usuarios normales y los que son empleados de *Valve*.
```{r valve-order}
# crear un nuevo data.frame ordenado por el numero de juegos
valve.order <- valve[order(valve$nJuegos),]
```

Visualizamos el número de juegos.
```{r plot-nJuegos-valve}
plot1 <- ggplot(valve.order, aes(x=c(1:nrow(valve.order)), y=nJuegos, color=VALVE))+
    geom_point(size=3, alpha=0.6)+
    labs(x="Indice", y="")+
    theme(plot.title = element_text(hjust = 0.5), legend.position="right")

plot2 <- ggplot(valve, aes(x=VALVE, y=nJuegos, col=VALVE))+
    geom_boxplot(outlier.size=3)+
    labs(y="Número de juegos")+
    theme(legend.position="none")

grid.arrange(plot2, plot1, ncol=2)
```

Se puede ver claramente que los que son empleados de *Valve* tienden a tener más juegos. No he encontrado una explicación oficial sobre esto, pero en Internet se pueden leer varios comentarios^[https://www.reddit.com/r/Steam/comments/2qtrrx/so_you_think_gabe_newell_can_play_any_game_he/cn9hvfl/]  hablando sobre que los empleados de *Valve* tienen un paquete especial que les permite comprar por 0€ cualquier juego dentro de la plataforma *Steam*. Otra explicación sería simplemente que al ser desarrolladores de videojuegos, tienen una pasión especial por ellos. 

La siguiente figura es el histograma de la frecuencia en función del número de juegos. La anchura de cada barra es de 20 juegos y la última barra representa el número de usuarios con mas de 800 juegos. La mayoría de usuarios tiene entre 1 y 20 juegos.

```{r histograma}
ggplot(steam, aes(x=nJuegos))+
    geom_histogram(breaks=c(seq(0,800,20), max(steam$nJuegos)), aes(fill = ..count..))+
    coord_cartesian(xlim=c(0,800))+
    annotate(geom="text", x=790, y=15, label="800+\njuegos")+
    labs(title="Histograma de número de juegos", x="Número de juegos")+
    theme(plot.title = element_text(hjust = 0.5))

summary(steam$nJuegos)
```

Ahora vamos a visualizar el número total de cada etiqueta. Las barras representan la suma total de cada columna (etiqueta). La figura está ordenada de mayor a menor. Claramente la etiqueta de Acción es la más popular de todas. En general los juegos de disparos (`Shooter` y `FPS`) son de lo más frecuentes, después están los juegos de habilidad, estrategia y plataformas. Los menos frecuentes son los juegos de carreras, deportes `JRPG` y `MMORPG`.

```{r conteo-etiquetas}
total.genero <- data.frame(genero=colnames(steam)[3:ncol(steam)],  total=sapply(steam[,3:ncol(steam)],sum))
total.genero <- total.genero[order(total.genero$total, decreasing=FALSE),]

# para que ggplot no los ordene alfabeticamente
total.genero$genero <- factor(total.genero$genero, levels=total.genero$genero)

ggplot(data=total.genero, aes(x=genero, y=total, color=genero, fill=genero))+
    geom_bar(stat="identity", width=0.7)+
    geom_text(aes(label=total), hjust=-0.1, size=4)+
    theme(legend.position="none")+
    coord_flip()
```

Antes de empezar con el análisis vamos a quitar los usuarios que tienen un número de juegos mucho mayor que el resto, los outliers. Vamos a Considerar outliers a jugadores con mas de 1000 juegos.

```{r rm-outliers}
outliers <- which(steam$nJuegos > 1000)

steam.filtrado <- steam[-outliers,]
rownames(steam.filtrado) <- 1:nrow(steam.filtrado)

valve.filtrado <- valve[-outliers,]
rownames(valve.filtrado) <- 1:nrow(valve.filtrado)
```

Hemos eliminado a `r length(outliers)` usuarios con más de 1000 juegos.

```{r}
summary(steam.filtrado$nJuegos)
```

En las siguientes figuras vamos a visualizar distintos boxplots. Para crear las figuras se ha usado la función `melt` del paquete `reshape2` para reordenar el `data.frame` según distintas variables y poder visualizarlo mejor con `ggplot2`. Primero vamos a representar el número de juegos y la comparativa entre las etiquetas `Singleplayer` y `Multiplayer`.

```{r boxplots-molten}
# numero de juegos
steam.molten <- melt(steam.filtrado, id.vars="steamid",
                     measure.vars="nJuegos")

plot3 <- ggplot(steam.molten, aes(x=variable, y=value))+
    geom_boxplot(fill="slateblue")

# singleplayer vs multiplayer
# punto verde representa la media
steam.molten <- melt(steam.filtrado, id.vars="steamid",
                     measure.vars=c("Singleplayer", "Multiplayer"))

plot4 <- ggplot(steam.molten, aes(x=variable, y=value, fill=variable))+
    geom_boxplot()+
    stat_summary(fun.y=mean, geom="point", shape=20, size=4, color="green", fill="green")+
    theme(legend.position="none")

grid.arrange(plot3, plot4, ncol=2)
```

En la siguiente imagen están los boxplots de todas las etiquetas.

```{r boxplots-molten-all}
# todos los generos
steam.molten <- melt(steam.filtrado, id.vars="steamid",
                     measure.vars=total.genero$genero)
ggplot(steam.molten, aes(x=variable, y=value, fill=variable, color=variable))+
    geom_boxplot(alpha=0.5)+
    theme(legend.position="none")+
    coord_flip()
```

Para hacer una visualización multivariante de cada usuario vamos a explorar los radarchart. 31 variables (las que corresponden solo a las etiquetas) son muchas para visualizarlas todas a la vez, pero como se verá en el siguiente apartado, están muy correlacionadas entre sí. Además, si en vez de visualizarlas en cualquier orden, las ordenamos según la similitud de las etiquetas como ya hemos hecho al principio de todo en la variable `orden.generos`, se puede conseguir una visualización bastante clara del gusto de cada usuario.

Lo siguiente es una función para comparar dos usuarios distintos en un mismo radarchart. Las variables se ordenan de tal modo que en la parte derecha del radarchart se queden las etiquetas que mejor representan a juegos de acción/disparos/violentos, en la parte izquierda los juegos de estrategia y habilidad, en la parte inferior los juegos de terror/zombis y en la superior el resto.

De este modo se puede ver de un vistazo que clase de juegos prefiere el usuario.

```{r function-radarchart}
radchart2 <- function(data1, data2){
    name1 <- data1$steamid
    name2 <- data2$steamid
    # ordenar las columnas para que en el radarchart
    # se queden agrupados las etiquetas de generos similares
    # dch=violento / izq=estrategia / abajo=horror / arriba=otros,deporte
    data1 <- data1[orden.generos]
    data2 <- data2[orden.generos]
    
    len <- ncol(data1)
    maximo <- max(c(as.integer(data1), as.integer(data2)))
    # las primeras dos filas tienen que ser el maximo y el minimo.
    data <- rbind(rep(maximo, len), rep(0, len), data1, data2)
    
    # http://www.r-graph-gallery.com/143-spider-chart-with-saveral-individuals/
    colors_border=c( rgb(0.2,0.5,0.5,0.9), rgb(0.8,0.2,0.5,0.9))
    colors_in=c( rgb(0.2,0.5,0.5,0.4), rgb(0.8,0.2,0.5,0.4))
    radarchart( data, axistype=1, pty=32,
                #custom polygon
                pcol=colors_border, pfcol=colors_in, plwd=1, plty=1,
                #custom the grid
                cglcol="grey", cglty=1, axislabcol="grey", cglwd=0.8,
                #custom labels
                vlcex=0.6
    )
    legend(x=1, y=1, legend=c(name1, name2), bty="n", pch=20,
           col=colors_in, text.col = "black", cex=0.5, pt.cex=1)
}
# http://blog.scottlogic.com/2011/09/23/a-critique-of-radar-charts.html
```

Vamos a aplicar la función anterior a dos usuarios.
```{r}
us1 <- 56 #111, 223
us2 <- 21 #210, 96
valve.filtrado[c(us1, us2),]
```

Como se puede ver, el usuario número `r us1` y `r us2` tienen una cantidad mas o menos similar de juegos. Si aplicamos el radarchart a estos dos:

```{r aplicar-radarchart}
radchart2(steam.filtrado[us1,], steam.filtrado[us2,])
```
Se puede ver que el usuario `r us1` destaca mucho en las etiquetas de Estrategia, Simulación e Indie[^indiefootnote] y muy poco en FPS y Shooter. En cambio el usuario `r us2` destaca sobre todo en Acción, FPS y Shooter y Horror. Los dos comparten prácticamente la misma puntuación en RPG.

[^indiefootnote]: Como se ha dicho en la introducción, Indie no es en sí un género, pero la mayoría de juegos independientes tienden más a la estrategia que a la acción.

## Correlacion

Ahora vamos a analizar la correlación entre las distintas etiquetas.

```{r correlacion}
# correlacion de steam sin outliers
correlacion <- cor(steam.filtrado[-c(1,2)])

# ordenar las variables por generos similares
cor.orden <- correlacion[orden.generos-2, orden.generos-2]
```

Las dos funciones siguientes son para conseguir las `n` variables que tienen más(menos) correlación con la variable `variable` dada una matriz de correlaciones en `mcor`. 

```{r funcion-correlacion}
maxcor <- function(variable, mcor, n=3){
    res <- sort(mcor[variable, ], decreasing=TRUE)
    return(res[2:(1+n)])
}

mincor <- function(variable, mcor, n=3){
    res <- sort(mcor[variable, ], decreasing=FALSE)
    return(res[2:(1+n)])
}
```

Vamos a aplicar estas funciones a unos casos:

```{r correlacion-shooter}
maxcor("Shooter", correlacion)
mincor("Shooter", correlacion)
```

```{r correlacion-indie}
maxcor("Indie", correlacion, 4)
```

Ya he mencionado antes (en la introducción y en la nota a pie de página 7) que los juegos independientes son en general juegos de habilidad y estrategia.

```{r correlacion-survival}
maxcor("Survival", correlacion, 5)
```

Este último ejemplo para la etiqueta `Survival` es más interesante de lo que parece. Desde que *Steam* empezó a aceptar el modelo de Early Access (por el año 2013-2014), han estado saliendo continuamente juegos usando este modelo de negocio. Algunos de estos juegos son de gran calidad y han acabado implementando todo lo que prometían. Sin embargo, una gran mayoría de juegos en Early Access son de muy dudosa calidad y al final no cumplen con lo prometido. Además, el bajo control de que hace *Valve* respecto a este tipo de juegos no ha ayudado a que el Early Access tenga una buena reputación (ver por ejemplo: ^[https://www.rockpapershotgun.com/2017/02/14/steam-curation-user-reviews-fixes/], ^[http://www.escapistmagazine.com/articles/view/video-games/editorials/17371-Dear-Valve-Please-Fix-Steam-in-2017], ^[http://www.thejimquisition.com/greenlight-wont-get-better-when-steam-wont-enforce-its-own-rules/]). El caso es que una buena parte de los juegos con la etiqueta de `Survival` son juegos en Early Access y suelen ser juegos multijugador (`Multiplayer`) en el que el objetivo es sobrevivir en un entorno difícil (muchas veces el enemigo son `Zombies`). La etiqueta `Simulation` también suele ser común[^earlyaccesstags]. Todo esto se puede apreciar en la correlación.

[^earlyaccesstags]: Es muy común que este tipo de juegos tenga estas otras etiquetas que no he tenido en cuenta en el dataset: `Open World`, `Crafting`, `Exploration`...

La siguiente función ordena los valores de la matriz de correlación de mayor a menor y quita los duplicados para ver cuales son las etiquetas que tienen la mayor correlación entre sí.

```{r fun-parescorrelados}
cor.vals <- unique(sort(correlacion, decreasing=TRUE))[-1]
paresCorrelados <- function(vals, n){
    res <- matrix(nrow=n, ncol=1)
    for(i in 1:n){
        # busca los indices que tiene el valor de correlacion 'cor.vals[i]'
        # dentro de la matriz de correlacion, y enseña los nombres de las variables
        names <- row.names(which(correlacion == cor.vals[i], arr.ind=T))
        res[i] <- paste(names[1], names[2], sep=" / ")
    }
    return(res)
}
```

Las 10 primeras correlaciones más grandes son:

```{r aplicar-parescorrelados}
paresCorrelados(cor.vals, 10)
```

La máxima correlación que hay en la matriz es de 0.9917623, entre `Shooter` y `FPS`. La segunda es de 0.9752353 entre `FPS` y `First.Person`. La tercera 0.9718287 entre `Shooter` y `First.Person`. Hay que tener en cuenta que `First.Person` no es un género, son los juegos en el que la cámara está en primera persona, pero la gran mayoría de juegos en primera persona son de disparos. En la siguiente imagen se visualizan las tres variables altamente correladas.

```{r pairs-plot}
pairs(steam.filtrado[,c("Shooter", "FPS", "First.Person")])
```

Finalmente, para acabar con el tema de la correlación vamos a ver el heatmap de la matriz de correlación para ver la correlación entre todas las etiquetas de un modo general. Del mismo modo que se ha hecho con el radarchart, las variables en la matriz de correlación `cor.orden` están ordenadas para agrupar las etiquetas similares.

```{r}
qplot(x=Var1, y=Var2, data=melt(cor.orden), fill=value, geom="tile") +
    scale_fill_gradient2(limits=c(-1, 1))+
    theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust=1),
          plot.title = element_text(hjust = 0.5))+
    labs(title="Heat map de la correlacion", x="", y="")
```

En general la correlación es alta (positiva) entre todas las variables. Esto tiene sentido ya que los juegos no tienen un único género, sino que mezclan distintos géneros a la vez. Además la gente no se suele centrar solamente en un mismo tipo de juego, prueba distintos géneros.

La alta correlación entre `Shooter`, `FPS` y `First.Person` se ve fácilmente. También se puede ver que hay una alta correlación entre `Puzzle`, `Platformer` y `Difficult`, muy razonable. `Strategy`, `Turn.Based.Strategy` y `Simulation` también.

También puede ser interesante reordenar las variables según los coeficientes de correlación, en vez de hacerlo a mano. La función corrplot en el paquete corrplot tiene distintos algoritmos para reordenar las variables. Ordenándolo según un clústering jerárquico el resultado es el siguiente:

```{r con-corrplot}
corrplot(correlacion, order="hclust", addrect=12,
         tl.col="black", tl.srt=60, tl.cex=0.7)
```

Los resultados del clústering son realmente buenos. Consigue agrupar las etiquetas similares.

# Procesado y análisis de los datos

## Análisis de componentes principales (PCA)

En este apartado vamos a hacer un PCA para reducir las variables de los datos. Antes de empezar hay que decidir si estandarizamos las variables o no (solo centradas). Por otra parte, hemos visto en el apartado anterior que las tres variables `Shooter`, `FPS` y `First.Person` están tan correlacionadas que podríamos considerarlas las mismas etiquetas. En las siguientes páginas[^pca1] y[^pca2] he encontrado comentarios que recomiendan (otros no) quitar las variables muy altamente correladas antes de aplicar PCA, porque al incluirlas el PCA aumentaría demasiado la contribución de esas variables redundantes (aunque todos tengan la misma dirección del autovector, el autovalor aumenta mucho y enmascara los otros).

[^pca1]: https://stats.stackexchange.com/questions/50537/should-one-remove-highly-correlated-variables-before-doing-pca
[^pca2]: https://stat.ethz.ch/pipermail/r-sig-ecology/2013-March/003624.html

Entre filtrar `FPS` y `First.Person` (para quedarnos solo con `Shooter`) o no filtrar nada no he encontrado grandes diferencias, al final he decidido no filtrar nada (excepto `steamid` y `nJuegos`) porque de este modo la interpretación de los componentes me parecía más intuitiva. También he decidido no estandarizar las variables por la misma razón.

```{r pca}
filtro1 <- c(1, 2)        # sin steamid, nJuegos
filtro2 <- c(1, 2, 21, 22)# sin steamid, nJuegos, FPS, First.Person
filtro <- filtro1
steam.pca <- prcomp(steam.filtrado[-filtro], scale. = FALSE)
```

Scree graph de los 10 primeros autovalores. La primera componente destaca mucho debido a la alta correlación que tienen todas las variables entre sí.

```{r scree-graph}
plot(steam.pca, type="l")
```


```{r}
lambda <- steam.pca$sdev^2 # valores propios
which(lambda > sum(lambda)/length(lambda))
```

Por lo menos hay que quedarse con las dos primeras componentes. La siguiente figura son los datos proyectados en las dos primeras componentes con un gradiente de colores que muestra el numero de juegos que tiene cada usuario. Aunque la variable `nJuegos` no se haya incluido en el PCA, está claro que PC1 es proporcional al numero de juegos.

```{r}
# nuevo data.frame con los datos en la nueva base
steam.pca.x <- data.frame(steamid=steam.filtrado$steamid, nJuegos=steam.filtrado$nJuegos, steam.pca$x)

ggplot(steam.pca.x , aes(x=PC1, y=PC2, color=nJuegos))+
    geom_point(size=2)+
    scale_color_gradient(low = "blue", high = "red")+
    theme(legend.position = "right")
```

Para ver la interpretación de las componentes vamos a calcular la correlación entre los datos originales y las componentes[^interpretarcomponentes].

[^interpretarcomponentes]: http://www.aaronschlegel.com/principal-component-analysis/

```{r correlacion-componentes}
cor(steam.filtrado[-filtro], steam.pca$x[,1:3])
```

La correlación entre las variables con PC1 es muy grande y positiva para todos los casos, por lo que añadir un juego más a la biblioteca, sea del género que sea, va a aumentar el valor de PC1. Esa es la razón por la que en la gráfica anterior el número de juegos (alternativamente, el dinero gastado) sea proporcional a PC1. En el caso de PC2 la interpretación es más interesante. Si solo nos fijamos en el signo[^nota-signo] de la correlación se puede ver que casi todas las etiquetas que contribuyen negativamente a PC2 son etiquetas de juegos de acción/violentos, mientras que los que contribuyen positivamente son más de estrategia/RPG/plataformas.

[^nota-signo]: El signo es arbitrario y puede ser diferente si se ejecuta el programa en otro sistema operativo o versión de R.

```{r fun-interpretar}
interpretar <- function(indice, limite){
    m <- cor(steam.filtrado[-filtro], steam.pca$x[,indice])
    m <- m[abs(m[,1]) > limite,, drop=FALSE]
    return(m)
}

interpretar(2, 0.3)
```


## Kmeans clustering

En este apartado vamos a explorar Kmeans clustering para agrupar a los usuarios similares. Primero ponemos una semilla al generador de números aleatorios para conseguir resultados reproducibles. Para hacer el Kmeans vamos a usar las primeras 7 componentes principales, ya que son suficientes para explicar más del 99% de la varianza de los datos.

```{r varianza-explicada}
sum(steam.pca$sdev[1:7]^2)/sum(steam.pca$sdev^2)
```


```{r datos-clustering}
# semilla
set.seed(1939)
# datos usados para hacer el clustering
datos <- steam.pca.x[c(3:9)]
```

En principio, no sabemos el número de clusters ideales para este problema en particular. Primero vamos a hacer unas pruebas basadas en el índice de bondad, después usaremos el índice de las siluetas y para acabar usaremos la librería NbClust para calcular otros índices.

### Índice de bondad

El índice de bondad expresa el porcentaje de la variabilidad total explicada debido a la variabilidad intra-clase (between). Vamos a calcular el índice de bondad usando el valor de `k` d 1 a 20.

```{r loop-indice-bondad}
kvals <- c(1:20)
ib <- vector()
for(k in kvals){
    km <- kmeans(datos, k, nstart=100, iter.max=100000)
    ib[k] <- km$betweenss/km$totss # indice bondad
}
plot(ib*100, type="b", xlab="clusters", ylab="betweenSS/totSS (%)", main="índice bondad")
abline(v=1:5, col="gray")
```

Se puede ver que el codo de la curva se consigue para k=3,4 con un IB de unos 85%.

### Índice de siluetas

Valor medio del índice de siluetas. 

```{r}
distancias <- dist(datos, method="euclidean", diag=TRUE, upper=TRUE)^2

km <- kmeans(datos, 2, nstart=100, iter.max=100000)
silk <- silhouette(km$cluster, distancias)

avg.width <- vector(mode="numeric", length=length(kvals))
for(k in 2:length(kvals)){
    km <- kmeans(datos, k, nstart=100, iter.max=100000)
    silk <- silhouette(km$cluster, distancias)
    avg.width[k] <- summary(silk)$avg.width
}

plot(avg.width, type="b", las=1, xlab="k", main="índice silueta")
```

El mayor índice de silueta se consigue con k=2.

```{r}
par(mfrow=c(1,2))
km2 <- kmeans(datos, 2, nstart=100, iter.max=100000)
sil2 <- silhouette(km2$cluster, distancias)

km4 <- kmeans(datos, 4, nstart=100, iter.max=100000)
sil4 <- silhouette(km4$cluster, distancias)

plot(sil2, col=sort(unique(km2$cluster))+1)
plot(sil4, col=sort(unique(km4$cluster))+1)
par(mfrow=c(1,1))
```

### Usando la librería NbClust

La librería `NbClust` ofrece 30 índices distintos para determinar el número óptimo de clusters.

```{r}
nb <- NbClust(datos, diss=distancias, distance=NULL, 
              min.nc=2, max.nc=10, method="kmeans", 
              index = "all")
```

Según la recomendación de `NbClust` el número óptimo de clusters es 2 por mayoría (8 votos), aun así, considero que 2 es un número muy pequeño y voy a probar con 4 clusters (6 votos) que es lo mismo que recomienda el índice de bondad.

```{r}
set.seed(2017)
nClust <- 4 #4
km <- kmeans(datos, nClust, nstart=100, iter.max=100000)

plot(steam.pca.x[,3], steam.pca.x[,4], xlab = "PC1", ylab="PC2",
     col=c("red", "green3", "blue", "black")[km$cluster])
# centros de cluster
points(km$centers[,1:2], pch=23, col="black",
       bg=c("red", "green3", "blue", "black"), cex=1.5)

# linea vertical sobre el valor medio de PC1 para los usuarios
# que tengan menos juegos que la mediana de nJuegos para cluster 1
medianClus1 <- median(steam.filtrado[which(km$cluster == 1),2]) # = 19
meanPC1 <- mean(steam.pca.x[which(steam.filtrado$nJuegos < medianClus1),3])
abline(v=meanPC1, lty=2, lwd=2)

legend("topleft", legend=km$size, pch=23, box.lty=0,
       pt.bg=c("red", "green3", "blue", "black"), title="usuarios/cluster")
```

En la figura se pueden ver todos los usuarios representados en el plano de las dos primeras componentes principales, separados en `r nClust` clusters, junto a los centros de los clusters. También se ha separado el plano con una linea vertical para el valor de PC1 = `r meanPC1`. Esta linea vertical representa el valor medio de PC1 para aquellos usuarios que tienen menos juegos que la mediana del número de juegos para el cluster 1 (mediana = `r medianClus1`). La explicación de esta linea vertical se verá en el siguiente paso.

Ahora vamos a visualizar el boxplot del número de juegos que tiene cada usuario separados por clusters.

```{r}
juegosPerClust <- data.frame(cluster=integer(), nJuegos=integer())
for(k in 1:nClust){
    for(i in which(km$cluster == k)){
        juegosPerClust <- rbind(juegosPerClust, data.frame(cluster=k, nJuegos=steam.filtrado[i,2]))
    }
}
juegosPerClust$cluster <- as.factor(juegosPerClust$cluster)
ggplot(juegosPerClust, aes(x=cluster, y=nJuegos, fill=cluster))+geom_boxplot()
```


Para intentar ver si se puede sacar algo más de información sobre los usuarios de cada cluster, vamos a extraer los `steamid` por cada cluster y explorar un poco el perfil de cada usuario usando la página <https://steamid.eu/multiple-steam-id-finder/> que permite hacer una búsqueda sobre una lista de `steamid`s.

En el cluster 1, hay 96 usuarios con un número de juegos menor que la mediana del número de juegos del cluster 1 (usuarios a la izquierda de la linea vertical discontinua de antes). De esos 96 usuarios solo 11 son activos, la fecha de última conexión varía desde unos pocos días hasta 5 meses. Los 85 restantes son cuentas abandonadas (la fecha de última conexión llega hasta los 12 años) o cuentas suspendidas por el sistema anti-trampas (VAC, Valve Anti Cheat). En el cluster 1, los que tienen más juegos que la mediana, prácticamente la mayoría son usuarios activos (excepto unas 10 cuentas abandonadas de un total de 103). En el cluster dos todos son activos. Para todos los otros clusters todos los jugadores son activos.

```{r}
for(k in 1:nClust){
    #print(sprintf("steamid para Cluster %d:", k))
    for(i in which(km$cluster == k)){
        if(steam.filtrado[i,2] < median(steam.filtrado[which(km$cluster == k),2]) ){
             #print(steam.filtrado[i,1])
        }
    } 
}
```

# Conclusiones

cosas sobre dataset, secuencial, no aleatorio, el nde juegos es en realidad el numero de "aplicaciones"...
Correlación hclust muy buenos resultados

Por lo que se puede decir que los jugadores con menos de 19 juegos son la mayoría cuentas muertas, hay que tener en cuenta que este dataset ha escaneado desde el principio de las cuentas de steam, así que estos son usuarios que se hicieron la cuenta hace muchos años pero no han vuelto a jugar. ver en